<!doctype html>
<html lang="no">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Bibster Administrator</title>
  <meta name="theme-color" content="#0B1020" />

  <style>
    :root{
      --bg0:#060814;
      --bg1:#0B1020;
      --bg2:#0D1633;

      --card:#0f1b33cc;
      --card2:#0b1326cc;

      --text:#EAF0FF;
      --muted:#AEBCE0;

      --stroke: rgba(255,255,255,.10);
      --stroke2: rgba(255,255,255,.06);

      --accent:#7CF3FF;
      --accent2:#9BFFB5;

      --danger:#FF6B6B;
      --warn:#FFD166;

      --radius:18px;
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      color:var(--text);
      background:
        radial-gradient(1200px 800px at 20% -10%, rgba(124,243,255,.18), transparent 60%),
        radial-gradient(900px 600px at 90% 0%, rgba(155,255,181,.14), transparent 55%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      min-height:100vh;
    }

    header{
      padding:18px 18px 10px;
      position:sticky;
      top:0;
      backdrop-filter: blur(10px);
      background: linear-gradient(180deg, rgba(6,8,20,.75), rgba(6,8,20,.15));
      border-bottom: 1px solid var(--stroke2);
      z-index:5;
    }

    .top{
      max-width:1200px;
      margin:0 auto;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }

    .brand{display:flex; flex-direction:column; gap:4px;}
    .brand h1{margin:0; font-size:18px; letter-spacing:.2px;}
    .brand p{margin:0; font-size:12.5px; color:var(--muted);}

    .btnrow{display:flex; gap:10px; flex-wrap:wrap; justify-content:flex-end}
    button{
      border:1px solid var(--stroke);
      background: linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.06));
      color:var(--text);
      padding:10px 12px;
      border-radius:14px;
      cursor:pointer;
      font-weight:600;
      letter-spacing:.2px;
    }
    button:hover{border-color: rgba(124,243,255,.35)}
    button.primary{
      border-color: rgba(124,243,255,.45);
      background: linear-gradient(180deg, rgba(124,243,255,.22), rgba(124,243,255,.10));
    }
    button.danger{
      border-color: rgba(255,107,107,.55);
      background: linear-gradient(180deg, rgba(255,107,107,.22), rgba(255,107,107,.10));
    }

    main{
      max-width:1200px;
      margin:0 auto;
      padding:14px 18px 24px;
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:14px;
    }

    .card{
      border:1px solid var(--stroke2);
      background: linear-gradient(180deg, var(--card), var(--card2));
      border-radius: var(--radius);
      overflow:hidden;
      box-shadow: 0 10px 40px rgba(0,0,0,.25);
    }
    .cardhead{
      padding:14px 14px 10px;
      border-bottom:1px solid var(--stroke2);
      display:flex;
      align-items:flex-end;
      justify-content:space-between;
      gap:10px;
    }
    .cardhead h2{margin:0; font-size:14px; letter-spacing:.2px;}
    .meta{
      font-size:12px;
      color:var(--muted);
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .pill{
      border:1px solid var(--stroke2);
      padding:4px 8px;
      border-radius:999px;
      background: rgba(255,255,255,.04);
    }

    textarea{
      width:100%;
      min-height:520px;
      resize:vertical;
      padding:12px 12px;
      border:0;
      outline:none;
      color:var(--text);
      background: transparent;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size:12.5px;
      line-height:1.45;
    }

    .foot{
      padding:12px 14px;
      border-top:1px solid var(--stroke2);
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      flex-wrap:wrap;
    }

    .errors{
      padding:12px 14px;
      border-top:1px solid var(--stroke2);
      background: rgba(0,0,0,.18);
      max-height:220px;
      overflow:auto;
    }
    .errors ul{margin:0; padding-left:18px}
    .errors li{margin:6px 0; color:var(--muted)}
    .errors li.bad{color:var(--danger)}
    .errors li.warn{color:var(--warn)}

    .hint{
      font-size:12px;
      color:var(--muted);
      padding:0 14px 14px;
    }

    /* Preview rows (green/red) */
    .preview {
      border-top: 1px solid var(--stroke2);
      padding: 10px 10px 12px;
      max-height: 240px;
      overflow: auto;
      background: rgba(0,0,0,.14);
    }
    .row {
      display: grid;
      grid-template-columns: 84px 1fr;
      gap: 10px;
      padding: 8px 10px;
      border: 1px solid var(--stroke2);
      border-radius: 12px;
      margin: 8px 4px;
      background: rgba(255,255,255,.03);
    }
    .row .ln {
      color: var(--muted);
      font-size: 12px;
      white-space: nowrap;
    }
    .row .txt {
      font-size: 12.5px;
      line-height: 1.35;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
    }
    .row.ok  { border-color: rgba(255,255,255,.10); }
    .row.dup { border-color: rgba(155,255,181,.55); background: rgba(155,255,181,.10); }
    .row.bad { border-color: rgba(255,107,107,.55); background: rgba(255,107,107,.12); }

    .row .badge {
      display:inline-block;
      margin-left:6px;
      padding:2px 8px;
      border-radius:999px;
      border:1px solid var(--stroke2);
      font-size:11px;
      color: var(--muted);
      vertical-align: middle;
    }
    .row.dup .badge{ border-color: rgba(155,255,181,.55); color: rgba(155,255,181,.95); }
    .row.bad .badge{ border-color: rgba(255,107,107,.55); color: rgba(255,107,107,.95); }

    @media (max-width: 980px){
      main{grid-template-columns: 1fr}
      textarea{min-height:420px}
    }
  </style>
</head>

<body>
  <header>
    <div class="top">
      <div class="brand">
        <h1>Bibster Administrator</h1>
        <p>Lim inn tabellen ‚Üí f√• korrekt <code>persons.json</code> live (hopper over f√∏rste datarad)</p>
      </div>
      <div class="btnrow">
        <button id="btnSample">Sett inn eksempel</button>
        <button id="btnNormalize">Normaliser input</button>
        <button class="primary" id="btnCopy">Kopier JSON</button>
        <button id="btnDownload">Last ned persons.json</button>
        <button class="danger" id="btnClear">T√∏m</button>
      </div>
    </div>
  </header>

  <main>
    <section class="card">
      <div class="cardhead">
        <h2>Tabell (TSV/Excel-kopi)</h2>
        <div class="meta">
          <span class="pill">St√∏tter tab-separert</span>
          <span class="pill">Kolonnenavn p√• f√∏rste linje</span>
          <span class="pill">Hopper over 1. datarad</span>
        </div>
      </div>

      <textarea id="tableInput" spellcheck="false" placeholder="Lim inn tabellen din her (inklud√©r kolonnenavn).&#10;&#10;Kolonner: NUMMER, KODE, NAVN, LEVDE/SKJEDDE, (Hint 1) F√òDT/OPPVOKST, (Hint 2) YRKE/ROLLE, (Hint 3) KJENNETEGN, PERSON/HENDELSE, PERSON/HENDELSE, PERSON/HENDELSE"></textarea>

      <div class="hint">
        ‚úÖ Viktig: Etter kolonneheaderen hopper vi over f√∏rste rad (den du bruker ‚Äúbare til informasjon‚Äù).<br/>
        üé® Under ser du rader farget: <b>r√∏d</b> = skippes, <b>gr√∏nn</b> = duplikat.
      </div>

      <!-- PREVIEW (THIS WAS MISSING IN YOUR FILE) -->
      <div class="preview" id="preview"></div>

      <div class="errors">
        <ul id="issues"></ul>
      </div>
    </section>

    <section class="card">
      <div class="cardhead">
        <h2>Generert persons.json</h2>
        <div class="meta">
          <span class="pill" id="rowCount">0 kort</span>
          <span class="pill" id="errCount">0 feil</span>
          <span class="pill" id="dupCount">0 duplikater</span>
          <span class="pill" id="typeCount">0 personer ‚Ä¢ 0 hendelser</span>
        </div>
      </div>

      <textarea id="jsonOutput" spellcheck="false" readonly></textarea>

      <div class="foot">
        <div style="color:var(--muted);font-size:12px">
          Slankt JSON: tomme felter droppes. R√∏de rader skippes.
        </div>
        <div style="display:flex; gap:10px; flex-wrap:wrap">
          <button id="btnMinify">Minify</button>
          <button id="btnPretty">Pretty</button>
        </div>
      </div>
    </section>
  </main>

  <script>
    // Kolonner -> inputfelt
    const COLUMN_ALIASES = {
      id: ["NUMMER","ID","NR"],
      code: ["KODE","CODE"],
      name: ["NAVN","NAME"],
      lived_text: ["LEVDE/SKJEDDE","LEVDE","SKJEDDE","LIVED","TID","PERIODE"],
      place: ["F√òDT/OPPVOKST","FODT/OPPVOKST","F√òDT","FODT","OPPVOKST","PLACE","ORIGIN"],
      role: ["YRKE/ROLLE","YRKE","ROLLE","ROLE"],
      tagline: ["KJENNETEGN","HINT","TAGLINE","KJENNETEGN/HINT"],
      type: ["PERSON / HENDELSE","PERSON/HENDELSE","TYPE","KORTTYPE"]
    };

    const elIn = document.getElementById("tableInput");
    const elOut = document.getElementById("jsonOutput");
    const elIssues = document.getElementById("issues");
    const elPreview = document.getElementById("preview");

    const elRowCount = document.getElementById("rowCount");
    const elErrCount = document.getElementById("errCount");
    const elDupCount = document.getElementById("dupCount");
    const elTypeCount = document.getElementById("typeCount");

    const btnCopy = document.getElementById("btnCopy");
    const btnDownload = document.getElementById("btnDownload");
    const btnClear = document.getElementById("btnClear");
    const btnSample = document.getElementById("btnSample");
    const btnNormalize = document.getElementById("btnNormalize");
    const btnMinify = document.getElementById("btnMinify");
    const btnPretty = document.getElementById("btnPretty");

    let currentData = [];
    let currentPretty = true;

    function guessDelimiter(line){
      const t = (line.match(/\t/g)||[]).length;
      const s = (line.match(/;/g)||[]).length;
      const c = (line.match(/,/g)||[]).length;
      if (t >= s && t >= c && t > 0) return "\t";
      if (s >= c && s > 0) return ";";
      if (c > 0) return ",";
      return "\t";
    }

    function safeStr(v){ return String(v ?? "").trim(); }

    function normalizeType(v){
      const s = safeStr(v).toLowerCase();
      if (!s) return "person";
      if (s.includes("hendelse") || s.includes("event")) return "event";
      if (s.includes("person")) return "person";
      return "person";
    }

    function normalizeHeader(h){
      // Fjern f.eks. "(Hint 1)"-prefiks og annen pynt i header
      let x = safeStr(h).replace(/^\s*\([^)]*\)\s*/,"");
      x = x.replace(/\s+/g," ").toUpperCase();
      // Normaliser: behold bokstaver/tall/√Ü√ò√Ö og /, erstatt resten med mellomrom
      x = x.replace(/[^0-9A-Z√Ü√ò√Ö\/]+/g, " ");
      x = x.replace(/\s+/g," ").trim();
      return x;
    }

    function findHeaderIndex(headers, wantedList){
      const map = new Map();
      headers.forEach((h,i)=>map.set(normalizeHeader(h), i));
      for (const w of wantedList){
        const key = normalizeHeader(w);
        if (map.has(key)) return map.get(key);
      }
      return -1;
    }

    function clearIssues(){ elIssues.innerHTML = ""; }
    function addIssue(text, cls=""){
      const li = document.createElement("li");
      if (cls) li.className = cls;
      li.textContent = text;
      elIssues.appendChild(li);
    }

    // ---- Tids-parser:
    // St√∏tter:
    //  - "ca. 2500‚Äì2300 fvt"
    //  - "2370 fvt"
    //  - "ca. 42 fvt ‚Äì 37 evt" (blandet era)
    // Returnerer: era ("BCE"|"CE"|"MIXED"|null), year_from, year_to, approx
    function parseLivedText(livedText){
      const raw = safeStr(livedText);
      if (!raw) return { era: null, year_from: null, year_to: null, approx: false };

      const approx = /\bca\.?\b/i.test(raw);

      // Normaliser dash
      const t = raw.replace(/[‚Äì‚Äî]/g, "-");

      // Del i to deler om mulig (from-to)
      const parts = t.split("-").map(s => s.trim()).filter(Boolean);

      function parsePart(part){
        const p = part.toLowerCase();
        const hasBce = /\bfvt\b/.test(p);
        const hasCe  = /\bevt\b/.test(p);
        const nums = (p.match(/\d{1,4}/g) || []).map(n => parseInt(n,10)).filter(n => !Number.isNaN(n));
        const year = nums.length ? nums[0] : null;

        let era = null;
        if (hasBce) era = "BCE";
        else if (hasCe) era = "CE";
        return { era, year };
      }

      const a = parsePart(parts[0] || t);
      const b = parts.length >= 2 ? parsePart(parts[1]) : { era: a.era, year: null };

      // Bestem era
      let era = a.era || b.era || null;
      if (a.era && b.era && a.era !== b.era) era = "MIXED";

      let year_from = a.year;
      let year_to = b.year;

      // Hvis bare ett tall finnes: behold kun year_from
      if (parts.length < 2) year_to = null;

      function applyEraSign(year, e){
        if (year === null || year === undefined) return null;
        if (e === "BCE") return -Math.abs(year);
        if (e === "CE") return Math.abs(year);
        return year; // MIXED h√•ndteres separat
      }

      if (era === "MIXED"){
        // Anta format "42 fvt - 37 evt"
        year_from = applyEraSign(year_from, a.era || "BCE");
        year_to   = applyEraSign(year_to,   b.era || "CE");
      } else {
        year_from = applyEraSign(year_from, era);
        year_to   = applyEraSign(year_to,   era);
      }

      return { era, year_from, year_to, approx };
    } 

    // Bygger "slankt" object: tar bare med felter som faktisk har innhold
    function addIf(out, key, val){
      if (val === undefined || val === null) return;
      if (typeof val === "string" && val.trim() === "") return;
      out[key] = val;
    }

    function buildPersonRow(base){
      const o = {};
      addIf(o, "id", base.id);
      addIf(o, "code", base.code);
      addIf(o, "name", base.name);
      addIf(o, "type", base.type || "person");
      addIf(o, "time_label", (base.type === "event") ? "Skjedde" : "Levde");

      addIf(o, "lived_text", base.lived_text);
      addIf(o, "place", base.place);
      addIf(o, "role", base.role);
      addIf(o, "tagline", base.tagline);

      // Avledede felt kun hvis lived_text finnes
      if (base.lived_text && base.lived_text.trim() !== ""){
        addIf(o, "era", base.era);
        addIf(o, "year_from", base.year_from);
        // year_to tas kun med hvis den finnes (ikke null)
        if (base.year_to !== null && base.year_to !== undefined) addIf(o, "year_to", base.year_to);
        if (base.approx === true) o.approx = true;
      }
      return o;
    }

    function parseTable(text){
      const raw = text.replace(/\r\n/g,"\n").replace(/\r/g,"\n");
      const lines = raw.split("\n").filter(l => l.trim().length > 0);
      if (!lines.length) return { rows: [], issues: [] };

      const delim = guessDelimiter(lines[0]);
      const headers = lines[0].split(delim).map(safeStr);

      const idx = {
        id: findHeaderIndex(headers, COLUMN_ALIASES.id),
        code: findHeaderIndex(headers, COLUMN_ALIASES.code),
        name: findHeaderIndex(headers, COLUMN_ALIASES.name),
        lived_text: findHeaderIndex(headers, COLUMN_ALIASES.lived_text),
        place: findHeaderIndex(headers, COLUMN_ALIASES.place),
        role: findHeaderIndex(headers, COLUMN_ALIASES.role),
        tagline: findHeaderIndex(headers, COLUMN_ALIASES.tagline),
        type: findHeaderIndex(headers, COLUMN_ALIASES.type),
      };

      const issues = [];
      for (const req of ["id","code","name","lived_text","place","role","tagline"]){
        if (idx[req] === -1){
          issues.push({ type:"bad", msg:`Mangler kolonne for ${req.toUpperCase()} (forventet f.eks. ${COLUMN_ALIASES[req].join(", ")})` });
        }
      }

      // Vanligvis har du en "info"-rad etter headeren som skal hoppes over.
// Hvis den IKKE finnes, skal vi ikke miste f√∏rste faktiske data-rad.
function looksLikeRealDataLine(line){
  const parts = line.split(delim);
  const idVal = safeStr(parts[idx.id]);
  const codeVal = safeStr(parts[idx.code]);
  const nameVal = safeStr(parts[idx.name]);
  const idOk = /^\d+\-\d+$/.test(idVal);
  const codeOk = /^[01]{10}$/.test(codeVal);
  return idOk && codeOk && !!nameVal;
}

// startRow:
// - 1 => vi leser fra f√∏rste linje etter header
// - 2 => vi hopper over info-raden (lines[1]) hvis den ikke ser ut som ekte data
let startRow = 1;
if (lines.length > 1 && !looksLikeRealDataLine(lines[1])) startRow = 2;

      const rows = [];
      for (let i = startRow; i < lines.length; i++){
        const parts = lines[i].split(delim);

        const lived_text = safeStr(parts[idx.lived_text]);
        const livedParsed = parseLivedText(lived_text);

        const base = {
          id: safeStr(parts[idx.id]),
          code: safeStr(parts[idx.code]),
          name: safeStr(parts[idx.name]),
          type: (idx.type !== -1) ? normalizeType(parts[idx.type]) : "person",
          lived_text,
          place: safeStr(parts[idx.place]),
          role: safeStr(parts[idx.role]),
          tagline: safeStr(parts[idx.tagline]),
          era: livedParsed.era,
          year_from: livedParsed.year_from,
          year_to: livedParsed.year_to,
          approx: livedParsed.approx
        };

        // dropp HELT tom linje
        const allEmpty = ["id","code","name","lived_text","place","role","tagline"].every(k => !base[k]);
        if (allEmpty) continue;

        rows.push({ base, sourceLine: i + 1 }); // 1-basert input-linje
      }

      return { rows, issues };
    }

    function analyzeRows(wrapped){
      const issues = [];
      let errorCount = 0;
      let dupCount = 0;

      const seenId = new Map();
      const seenCode = new Map();

      const analyzed = wrapped.map((w) => {
        const r = w.base;
        const lineNo = w.sourceLine;

        let status = "ok";
        let tag = "OK";
        let skip = false;

        // Skipp-kriterier
        const missingCore = (!r.id || !r.code || !r.name);
        const badCodeChars = (r.code && !/^[01]+$/.test(r.code));
        const badCodeLen = (r.code && /^[01]+$/.test(r.code) && r.code.length !== 10);

        if (missingCore){
          status = "bad"; tag = "SKIP: mangler id/code/name"; skip = true;
          issues.push({ type:"bad", msg:`Linje ${lineNo}: Mangler id/code/name.` });
          errorCount++;
        } else if (badCodeChars){
          status = "bad"; tag = "SKIP: kode ikke 0/1"; skip = true;
          issues.push({ type:"bad", msg:`Linje ${lineNo}: KODE har andre tegn enn 0/1: "${r.code}"` });
          errorCount++;
        } else if (badCodeLen){
          status = "bad"; tag = "SKIP: kode != 10"; skip = true;
          issues.push({ type:"bad", msg:`Linje ${lineNo}: KODE er ${r.code.length} tegn (forventet 10): "${r.code}"` });
          errorCount++;
        }

        // Duplikater (markeres gr√∏nne, men skippes ikke)
        if (!skip){
          if (r.id){
            if (seenId.has(r.id)){
              status = "dup";
              tag = `DUP ID (f√∏rst ${seenId.get(r.id)})`;
              dupCount++;
              issues.push({ type:"warn", msg:`Linje ${lineNo}: Duplikat ID "${r.id}" (f√∏rst linje ${seenId.get(r.id)}).` });
            } else seenId.set(r.id, lineNo);
          }
          if (r.code){
            if (seenCode.has(r.code)){
              status = "dup";
              tag = `DUP KODE (f√∏rst ${seenCode.get(r.code)})`;
              dupCount++;
              issues.push({ type:"warn", msg:`Linje ${lineNo}: Duplikat KODE "${r.code}" (f√∏rst linje ${seenCode.get(r.code)}).` });
            } else seenCode.set(r.code, lineNo);
          }
        }

        // Advarsel hvis LEVDE finnes men era ikke finnes (ikke skipp)
        if (!skip && r.lived_text && !r.era){
          issues.push({ type:"warn", msg:`Linje ${lineNo}: Fant ikke "fvt" eller "evt" i LEVDE: "${r.lived_text}"` });
        }

        return { ...w, status, tag, skip };
      });

      return { analyzed, issues, errorCount, dupCount };
    }

    function renderPreview(analyzed){
      elPreview.innerHTML = "";
      analyzed.forEach(w => {
        const r = w.base;
        const div = document.createElement("div");
        div.className = `row ${w.status}`;
        div.innerHTML = `
          <div class="ln">Linje ${w.sourceLine}<span class="badge">${w.tag}</span><span class="badge">${(r.type === "event") ? "HENDELSE" : "PERSON"}</span></div>
          <div class="txt">${r.id || "?"}	${r.code || "?"}	${r.name || "?"}	${r.lived_text || ""}	${r.place || ""}	${r.role || ""}	${r.tagline || ""}	${(r.type === "event") ? "Hendelse" : "Person"}</div>
        `;
        elPreview.appendChild(div);
      });
    }

    function prettyJson(data){ return JSON.stringify(data, null, 2) + "\n"; }
    function minifyJson(data){ return JSON.stringify(data) + "\n"; }

    function render(){
      clearIssues();

      const parsed = parseTable(elIn.value);
      parsed.issues.forEach(x => addIssue(x.msg, x.type));

      const a = analyzeRows(parsed.rows || []);
      a.issues.forEach(x => addIssue(x.msg, x.type));
      renderPreview(a.analyzed);

      // Kun rader som IKKE skippes -> JSON
      const jsonRows = a.analyzed
        .filter(w => !w.skip)
        .map(w => buildPersonRow(w.base))
        // ekstra sikkerhet: hvis id likevel tom (skal ikke skje), dropp
        .filter(o => o.id && String(o.id).trim() !== "");

      currentData = jsonRows;

      const personCount = jsonRows.filter(o => (o.type || "person") === "person").length;
      const eventCount  = jsonRows.filter(o => (o.type || "person") === "event").length;
      elRowCount.textContent = `${personCount} personer ‚Ä¢ ${eventCount} hendelser`;
      elErrCount.textContent = `${a.errorCount} feil`;
      elDupCount.textContent = `${a.dupCount} duplikater`;

      elOut.value = currentPretty ? prettyJson(currentData) : minifyJson(currentData);
    }

    // Buttons
    btnCopy.addEventListener("click", async () => {
      try{
        await navigator.clipboard.writeText(elOut.value);
        btnCopy.textContent = "Kopiert!";
        setTimeout(() => btnCopy.textContent = "Kopier JSON", 900);
      }catch(e){
        alert("Klarte ikke √• kopiere automatisk. Marker og kopier manuelt.");
      }
    });

    btnDownload.addEventListener("click", () => {
      const blob = new Blob([elOut.value], { type:"application/json;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "persons.json";
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    });

    btnClear.addEventListener("click", () => {
      elIn.value = "";
      render();
    });

    btnSample.addEventListener("click", () => {
      elIn.value =
`NUMMER	KODE	NAVN	LEVDE	F√òDT/OPPVOKST	YRKE/ROLLE	KJENNETEGN	PERSON/HENDELSE
INFO	INFO	INFO	Denne raden hoppes over (eller tolkes som info)				
1-1	1010011100	Adam	ca. 4026 fvt	Eden		Br√∏t Guds bud	Person
1-1	1010011100	Adam (duplikat)	ca. 4026 fvt	Eden		Br√∏t Guds bud	Person
	0110100101	Mangler ID	ca. 4026 fvt	Eden		Blir skippet	Person
1-2	0110100101	Eva	ca. 4026 fvt	Eden	F√∏rste kvinne	Ble fristet av slangen	Person
23-2	1010011110	Keiser Tiberius	ca. 42 fvt ‚Äì 37 evt	Roma	Keiser	Regjerte under Jesu tjeneste	Person
25-1	0001011101	Vannflommen √∏delegger verden	2370 fvt	√òdeleggende	Verdensomspennende √∏deleggelse	En vannkatastrofe utsletter alt liv	Hendelse`;
      render();
    });

    btnNormalize.addEventListener("click", () => {
      const raw = elIn.value.replace(/\r\n/g,"\n").replace(/\r/g,"\n");
      const lines = raw.split("\n").filter(l => l.trim().length > 0);
      if (!lines.length) return;

      const delim = guessDelimiter(lines[0]);
      const norm = lines.map(line => line.split(delim).map(safeStr).join("\t")).join("\n");
      elIn.value = norm + "\n";
      render();
    });

    btnMinify.addEventListener("click", () => {
      currentPretty = false;
      elOut.value = minifyJson(currentData);
    });

    btnPretty.addEventListener("click", () => {
      currentPretty = true;
      elOut.value = prettyJson(currentData);
    });

    elIn.addEventListener("input", render);

    // Initial
    render();
  </script>
</body>
</html>
